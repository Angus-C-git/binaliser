#!/usr/bin/python3

from elftools.elf.sections import Symbol
from pwn import *
import subprocess
import sys
import os
from operator import getitem
from collections import OrderedDict
from pwnlib import timeout

from pwnlib.asm import _objdump

import pprint

from pwnlib.rop import gadgets
from pwnlib.util.iters import pad
pp = pprint.PrettyPrinter(indent=4)

CHECK_SEC = 'checksec'
ROPPER = 'ropper'


RELRO   = "Full RELRO"
CANARY  = "Canary found"
NX      = "NX enabled"
PIE     = "PIE enabled"


TARGET_BIN = None

# Lines to receive before
# timeout
RCV_BEFORE = 25

# UI

PAD_BASE = ' ' * 12
logging.disable()


def print_banner():

    print('''
          ____  ____ ___ _   _    _    _     ___ ____  _____ ____   ____  
         / / / | __ )_ _| \ | |  / \  | |   |_ _/ ___|| ____|  _ \  \ \ \ 
        / / /  |  _ \| ||  \| | / _ \ | |    | |\___ \|  _| | |_) |  \ \ \   
        \ \ \  | |_) | || |\  |/ ___ \| |___ | | ___) | |___|  _ <   / / /
         \_\_\ |____/___|_| \_/_/   \_\_____|___|____/|_____|_| \_\ /_/_/ 
    ''')

def print_results(tactics):
    pad_base = ' ' * 12
    pad_inner = ' ' * 14
    pad_inner_inner = ' ' * 18

    tactics = OrderedDict(sorted(tactics.items(), 
                    key = lambda x: getitem(x[1], 'weight'), reverse=True))

    # print common
    print(f"{pad_base}[*] General Tactics\n")
    for strategy in tactics['common']['strategies']:
        print(f"{pad_inner} ‣ {strategy}")

    # tactics by weight
    print(f"\n{pad_base}[*] Tactics By Weight\n")
    rank = 1
    for tactic in tactics:
        if tactic == 'common': continue
        print(f'\n{pad_inner} [{rank}] :: [{tactic}]\n')
        for strategy in tactics[tactic]['strategies']:
            print(f"{pad_inner_inner} ‣ {strategy}")
        rank += 1


def fuzz_fmtstr(test_payload):
    try:
        proc = process(TARGET_BIN)
        # Attempt to catch a simple prompt
        proc.recvlines(RCV_BEFORE, timeout=1.5)
        proc.sendline(test_payload)
        return proc.recvall()

    except Exception as e:
        print('''
            Automatically detecting the offset failed
            likely because the input point to the binary
            is not simplistic or vulnerable.
        ''')
        print(f"{PAD_BASE}ERR :: {e}")


def fuzz_offsets(fmtstr_mode=0):
    pad_base = ' ' * 12
    
    print(f'''
        [>>] Fuzzing for offsets
    ''')

    # :: Try to find offsets for both bof and fmt ::

    # if (fmtstr_mode):
    try:
        fmtstr_fuzz = FmtStr(execute_fmt=fuzz_fmtstr)
        offset = fmtstr_fuzz.offset
        print(f'{pad_base}Found possible offset for format str @ {hex(offset)}')
    except Exception as e:
        print('''
            Automatically detecting the offset for a format str 
            failed likely because the input point to the binary
            is not simplistic or vulnerable ...

            Note : This is expected if a return pointer offset was found.
        ''')
        print(f"{pad_base}ERR :: {e}")
    
    offset_test = cyclic(1000)
    try:
        proc = process(TARGET_BIN)
        # Attempt to catch a simple prompt
        proc.recvlines(RCV_BEFORE, timeout=1.5)
        proc.sendline(offset_test)

        core = Coredump('./core')
        offset = cyclic_find(core.eip)
        print(f'{pad_base}Found possible return pointer offset @ {hex(offset)}')
        
        # cleanup
        # os.remove('./core')
        proc.close()
    except Exception as e:
        print('''
            Automatically detecting the offset for a BOF failed
            likely because the input point to the binary
            is not, simplistic, vulnerable or uses a canary ...

            Note : This is expected if a format string offset was found.
        ''')
        print(f"{pad_base}ERR :: {e}, was the core dumped?")



def interpret_results(results, win, options):
    
    strategies = {
        'GOT_RW': 'Overwrite GOT Entry',
        'canary': 'Attempt to leak or bruteforce stack canary',
        'NX_BOF': 'Attempt return to win function',
        'shellcode': 'Attempt to execute shellcode in a stack buffer',
        'leak': 'Attempt to obtain a region leak such as an address on the stack',
        'win' : 'Attempt return to win function',
        'return_ptr': 'Linear overwrite of return pointer'
    }

    tactics = {
        'rop': {
            'weight': 0,
            'strategies': []
        },
        'bof': {
            'weight': 0,
            'strategies': []
        },
        'fmt_str': {
            'weight': 0,
            'strategies': []
        },
        'common': {
            'weight': 0,
            'strategies': []
        }
    }

    if (win):
        tactics['common']['strategies'].append(strategies['win'])

    # Memory protections disabled
    if (RELRO not in results[2]):
        tactics['fmt_str']['weight'] += 1
        tactics['fmt_str']['strategies'].append(strategies['GOT_RW'])
    if (CANARY not in results[3]):
        tactics['bof']['weight'] += 1
        tactics['bof']['strategies'].append(strategies['return_ptr'])
    if (NX not in results[4]):
        tactics['bof']['weight'] += 1
        tactics['bof']['strategies'].append(strategies['shellcode'])
    if (PIE not in results[5]):
        pass
    

    # Memory protections enabled
    if (RELRO in results[2]):
        tactics['fmt_str']['weight'] -= 1
    if (CANARY in results[3]):
        tactics['bof']['strategies'].append(strategies['canary'])
    if (NX in results[4]):
        if (win):
            tactics['bof']['weight'] += 1
        else:
            tactics['bof']['weight'] -= 1
        
        tactics['rop']['weight'] += 1
        tactics['fmt_str']['weight'] += 1

    if (PIE in results[5]):
        tactics['common']['strategies'].append(strategies['leak'])

    print_results(tactics)
    # TODO :: Allow for fmt str
    if ('-a' in options):
        fuzz_offsets()


# TODO :: Fix awful prints with specifiers
def analyze(target_bin, options=[]):
    print_banner()
    global TARGET_BIN
    
    pad = ' ' * 12
    adjusted_pad = ' ' * 8

    elf = ELF(target_bin, checksec=False)
    TARGET_BIN = target_bin

    # TODO :: mutate win
    try:
        win_function = elf.symbols['win']
    except:
        win_function = None
    
    print(f'''
        [>>] Analysing {TARGET_BIN} 
    ''')

    checksec_res = subprocess.run([CHECK_SEC, TARGET_BIN], capture_output=True, text=True)
    results = checksec_res.stderr.split('\n')

    for protection in range(1, 6):
        print(f'{adjusted_pad}{results[protection]}',end=None)

    if (win_function is not None):
        print(f'\n{pad}Likely win function @ {hex(win_function)}')

    # run ropper cause inbuilt is ordinary  
    ropper_res = subprocess.run([ROPPER, '-f', TARGET_BIN], capture_output=True, text=True)
    num_gadgets = int(ropper_res.stdout[-20:-15])
    
    print(f'\n{pad}Binary has {num_gadgets} unique gadgets')




    print('\n       [>>] Determining possible strategies\n')

    # TODO :: Add more metrics
    interpret_results(results, win_function is not None, options)



    print('\n')


if __name__ == '__main__':
    
    # TODO :: Convert to use argparser 
    if (len(sys.argv) < 2 or (len(sys.argv) > 3)):
        print_banner()

        print(f'''

            usage :: {sys.argv[0]} <file> [options]

            ::::::::::::::::::::::::: [options] :::::::::::::::::::::::::

            -gt, --gadget-threshold     threshold for number of gadgets
                                        to use for ROP weights 
            -a,  --auto                 automatically fuzz for offsets
        ''')
        exit(0)
    if (len(sys.argv) == 3): analyze(sys.argv[1], sys.argv[2])
    else: analyze(sys.argv[1])

